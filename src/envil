#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/statedir.nu *

def main [] {
    help main
}

def select-envname [envname state] {
    let envname = if $envname == "" {
        $state.envs | columns | input list -f "Select which env to use:"
    } else {
        $envname
    }
    if $envname in ["default"] {
        error make {msg: $"`($envname)' is a reserved name, please rename the environment"}
    }
    $envname
}

# Print out the flake that will generate the <envname> environment
def "main gen-flake" [
    envname = "" # The name of the env to generate a flake for
    --statedir (-d) = "" # Where to read the envil state from
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state
    generate-flake $envname $state $systems
}

def write-flake [envname state] {
    let flakepath = [$state.statedir env-flakes $envname] | path join | path expand
    mkdir $flakepath
    generate-flake $envname $state | save -rf ([$flakepath flake.nix] | path join)
    $"path:($flakepath)"
}

# Start a subshell containing <envname>, or run a command in this subshell
def "main shell" [
    envname: string = "" # The environment to open in a subshell
    --statedir (-d) = "" # Where to read the envil state from and write the temporary flake.nix
    ...cmd # The command to run and its args
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state
    let flakepath = write-flake $envname $state
    print $"(ansi grey)Starting a subshell with env (ansi yellow)`($envname)'(ansi grey)...(ansi reset)"
    let args = if ($cmd | is-empty) {[]} else {["-c"] | append $cmd}
    SHELL_ENV=$envname ^nix shell $flakepath ...$args
}

# Print the current config of each env
def "main info" [
    --statedir (-d) = "" # Where to read the envil state from
] {
    let state = get-state $statedir
    print $"(ansi grey)Reading info from statedir (ansi yellow)`($state.statedir)'(ansi grey):\n"
    print $"(ansi green)($state | reject statedir | to yaml)(ansi reset)"
}

# Set the default envil statedir to <statedir>
def "main set-statedir" [
    statedir # A directory meant to contain an `envil-state.yaml' file and flakes generated from it
] {
    set-statedir $statedir
    print $"(ansi grey)Default state dir set to (ansi yellow)`($statedir)'(ansi reset)"
}

# Apply the selected environment, ie. switch the bins in `.envil/current/bin' to those of <envname>
def "main switch" [
    envname: string = "" # The environment to switch to
    --statedir (-d) = "" # Where to read the envil state from and write the temporary flake.nix
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state
    let flakepath = write-flake $envname $state
    ^nix build $flakepath -o ([$env.HOME .envil current] | path join)
    print $"(ansi grey)Switched to env (ansi yellow)`($envname)'(ansi reset)"
}

# Update an environment's inputs (package sources), and update its associated flake.lock file
#
# This will NOT rebuild the environment, you need to do an `envil switch/shell' again afterwards
def "main update" [
    envname: string = "" # The environment whose flake.lock should be updated
    --statedir (-d) = "" # Where to read the envil state and look for flake.nix/lock files
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state
    let flakepath = write-flake $envname $state
    ^nix flake update --flake $flakepath
    print $"Updated flake.lock for env (ansi yellow)`($envname)'(ansi reset)"
}
