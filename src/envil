#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/state.nu *

def main [] {
    help main
}

def select-envnames [multiple state --verb="use"] {
    let prompt = $"Select the env \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb):"
    let prompt_multi = $"Select the envs \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb) \(space to select):"
    
    $state.envs |
        transpose name desc |
        flatten |
        select name description? |
        update description {|e|
            $"($e.name) (ansi grey)\(($e.description))(ansi reset)"
        } |
        sort-by -i name |
        if $multiple {
            input list -d description -m $prompt_multi
        } else {
            input list -d description -f $prompt | [$in]
        } |
        get name
}

# Print out the flake that will generate the <envname> environment
def "main flake" [
    envname: string = ""
    --statedir (-d): path = "" # Where to read the envil state from
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = if ($envname == "") {
        select-envnames false $state --verb "create a flake for"
    } else {
        $envname
    }
    set-currents --statedir $state.statedir
    generate-flake $envname $state $systems
}

def write-flakes [envnames state] {
    let flakes = $envnames | each {|envname|
        let flakepath = [$state.statedir env-flakes $envname] | path join
        mkdir $flakepath
        generate-flake $envname $state | save -rf ([$flakepath flake.nix] | path join)
        if (not ([$flakepath flake.lock] | path join | path exists)) {
            do_update $flakepath
        }
        {envname: $envname, flakepath: $flakepath}
    }
    if ($flakes | length) == 1 {
        $flakes.0.flakepath
    } else {
        let m_flakepath = [$state.statedir multienv-flake] | path join
        rm -rf $m_flakepath
        mkdir $m_flakepath
        let m_state = {
            inputs: ($flakes | each {{$in.envname: $"path:($in.flakepath)"}} | into record)
            envs: {
                multienv: {
                    contents: ($envnames | each {{$in: [__current]}} | into record)
                }
            }
            statedir: $state.statedir
        }
        generate-flake "multienv" $m_state | save -rf ([$m_flakepath flake.nix] | path join)
        $m_flakepath
    }
}

# Start a subshell containing <envname>, or run a command in this subshell
def "main shell" [
    --multiple (-m) # Whether to merge multiple environments
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix
] {
    if ($env.SHELL_ENV? != null) {
        error make {msg: "Nested subshells are not supported"}
    }
    let state = get-state $statedir
    let envnames = select-envnames $multiple $state --verb "use in the subshell"
    let flakepath = write-flakes $envnames $state
    let merged_name = $envnames | str join "+"
    print $"(ansi grey)Starting a subshell with env (ansi yellow)`($merged_name)'(ansi grey)...(ansi reset)"
    set-currents --statedir $state.statedir
    try {
        SHELL_ENV=$merged_name ^nix shell $"path:($flakepath)#__current"
    } catch {
        print $"(ansi grey)Last subshell command exited with (ansi yellow)($env.LAST_EXIT_CODE)(ansi reset)"
    }
}

def do_switch [envstack state] {
    let flakepath = write-flakes $envstack $state
    ^nix build $"path:($flakepath)#__current" -o ([~ .envil current] | path join | path expand -n)
    set-currents --envstack $envstack --statedir $state.statedir
}

# Switch the entire stack to the selected environment
def "main switch" [
    --multiple (-m) # Whether to activate multiple environments or not
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix
] {
    let state = get-state $statedir
    let envnames = select-envnames $multiple $state --verb "switch to"
    do_switch $envnames $state
    print $"(ansi grey)Switched to (ansi yellow)`($envnames | str join "+")'(ansi reset)"
}

# Add a new environment on top of the stack, so its tools can be in the PATH too
def "main add" [
    envname: string = "" # Which env to stack on
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix
] {
    let state = get-state $statedir
    let stack = (get-currents).envstack? | or-else []
    let envname = if ($envname == "") {
        select-envnames false $state --verb "stack on" | get 0
    } else {
        $envname
    }
    do_switch ($stack ++ [$envname]) $state
    print $"(ansi grey)Stacked env (ansi yellow)`($envname)'(ansi reset)"
}

# Remove the environment on top of the stack
def "main pop" [] {
    let state = get-state ""
    let stack = (get-currents).envstack? | or-else []
    let last = try { $stack | last } catch { null }
    if $last == null {
        print $"(ansi grey)No env is on the stack(ansi reset)"
    } else {
        do_switch ($stack | drop 1) $state
        print $"(ansi grey)Popped env (ansi yellow)`($last)'(ansi reset)"
    }
}

def ls_or_empty [folder] {
    try {
        ls -s $folder | get name
    } catch {
        []
    }
}

# Report if some bins are present several times in your PATH, but pointing to different actual executables, thus creating an ambiguity
def "main checkpath" [
    --all (-a) # Check for all bins, not just those in the nix store
] {
    let bins = $env.PATH | each {|p| try {ls $p} catch {[]} | insert source $p} | flatten | rename -c {name: path} |
               insert stem {$in.path | path parse | get stem} | update path {path expand} |
               if $all { $in } else { where path starts-with /nix/store }
    let bins = $bins | group-by stem --to-table | each {{group: $in.group, items: ($in.items | uniq-by path | uniq-by source)}}
    for bin in $bins {
        if (($bin.items | length) >= 2) {
            print $"(ansi yellow)`($bin.group)'(ansi reset) is present more than once in your PATH. Found in: ($bin.items.source)"
        }
    }
}

# Get the current environment, ie. the last environment the user switched to, and the env activated in a subshell (if any)
def "main current" [] {
    let currents = get-currents
    if ($currents | is-empty) {
        print $"(ansi yellow)No activated env and no known statedir(ansi reset)"
    }
    if ($currents.statedir? != null) {
        print $"- Last statedir used: (ansi yellow)`($currents.statedir)'(ansi reset)"
    }
    print $"- Env\(s) on the stack: (ansi yellow)($currents.envstack? | or-else [])(ansi reset)"
    let binlist = $"(ls_or_empty ([~ .envil current bin] | path join | path expand -n) | sort -i)"
    print $"  | bins: ($binlist)"
    if ($env.SHELL_ENV? != null) {
        print $"- Env in this subshell: (ansi yellow)`($env.SHELL_ENV)'(ansi reset)"
        let binlist = $"($env.PATH | where {str ends-with "-envil/bin"} | ansi strip | each {ls_or_empty $in} | flatten | sort -i)"
        print $"  | bins: ($binlist)"
    }
}

def do_update [flakepath] {
    try {
        ^nix flake update --flake $"path:($flakepath)"
    } catch {
        # We may be on an older version of nix where the --flake arg does not exist yet
        ^nix flake update $"path:($flakepath)"
    }
}

# Update an environment's inputs (package sources), and update its associated flake.lock file
#
# This will NOT rebuild the environment, you need to do an `envil switch/shell' again afterwards
def "main update" [
    envname: string = "" # The environment whose flake.lock should be updated
    --statedir (-d): path = "" # Where to read the envil state and look for flake.nix/lock files
] {
    let state = get-state $statedir
    let envname = if ($envname == "") {
        select-envnames false $state --verb "update" | get 0
    } else {
        $envname
    }
    let flakepath = write-flakes [$envname] $state
    do_update $flakepath
    set-currents --statedir $state.statedir
    print $"Updated flake.lock for env (ansi yellow)`($envname)'(ansi reset)"
}

# Deactivate any env that we have switched to (envil adds nothing more to the PATH)
def "main deactivate" [] {
    let currents = get-currents
    try {
        erase-current-env
        rm ([~ .envil current] | path join | path expand -n)
    } catch {
        print $"(ansi yellow)No env was activated(ansi reset)"
    }
    try {
        print $"(ansi grey)Env (ansi yellow)`($currents.env)'(ansi grey) env has been deactivated(ansi reset)"
    }
}
