#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/state.nu *

def main [] {
    help main
}

def select-envname [envname state --verb="use"] {
    let envname = if $envname == "" {
        $state.envs | columns | sort |
        input list -f $"Select the env \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb):"
    } else {
        $envname
    }
    if $envname in ["default"] {
        error make {msg: $"`($envname)' is a reserved name, please rename the environment"}
    }
    $envname
}

# Print out the flake that will generate the <envname> environment
def "main flake" [
    envname = "" # The name of the env to generate a flake for
    --statedir (-d) = "" # Where to read the envil state from
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state --verb "generate a flake from"
    generate-flake $envname $state $systems
}

def write-flake [envname state] {
    let flakepath = [$state.statedir env-flakes $envname] | path join | path expand
    mkdir $flakepath
    generate-flake $envname $state | save -rf ([$flakepath flake.nix] | path join)
    $"path:($flakepath)"
}

# Start a subshell containing <envname>, or run a command in this subshell
def --wrapped "main shell" [
    envname: string = "" # The environment to open in a subshell
    --statedir (-d) = "" # Where to read the envil state from and write the temporary flake.nix
    ...cmd # The command to run and its args
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state --verb "use in the subshell"
    let flakepath = write-flake $envname $state
    print $"(ansi grey)Starting a subshell with env (ansi yellow)`($envname)'(ansi grey)...(ansi reset)"
    let args = if ($cmd | is-empty) {[]} else {["-c"] | append $cmd}
    try {
        SHELL_ENV=$envname ^nix shell $flakepath ...$args
    } catch {
        print $"(ansi grey)Last subshell command exited with (ansi yellow)($env.LAST_EXIT_CODE)(ansi reset)"
    }
}

# Print the current config of each env
def "main envs" [
    --statedir (-d) = "" # Where to read the envil state from
] {
    let state = get-state $statedir
    print $"(ansi green)($state | reject statedir | to yaml)(ansi reset)"
    print $"(ansi grey)[Config read from statedir (ansi yellow)`($state.statedir)'(ansi grey)](ansi reset)"
}

# Set the default envil statedir to <statedir>
def "main setdir" [
    statedir # A directory meant to contain an `envil-state.yaml' file and flakes generated from it
] {
    set-statedir $statedir
    print $"(ansi grey)Default statedir set to (ansi yellow)`($statedir | path expand)'(ansi reset)"
}

# Apply the selected environment, ie. switch the bins in `.envil/current/bin' to those of <envname>
def "main switch" [
    envname: string = "" # The environment to switch to
    --statedir (-d) = "" # Where to read the envil state from and write the temporary flake.nix
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state --verb "switch to"
    let flakepath = write-flake $envname $state
    ^nix build $flakepath -o ([$env.HOME .envil current] | path join)
    set-cur-env $envname $state.statedir
    print $"(ansi grey)Switched to env (ansi yellow)`($envname)'(ansi reset)"
}

# Get the current environment, ie. the last environment the user switched to
def "main current" [] {
    let currents = get-cur-env
    if ($currents == null) {
        print "No env is activated currently"
    } else {
        print $"Current env is (ansi yellow)`($currents.env)'(ansi reset) \(from statedir (ansi yellow)`($currents.src_statedir)'(ansi reset))"
        print "Bins in scope:"
        ls -s ([$env.HOME .envil current bin] | path join) | get name
    }
}

# Update an environment's inputs (package sources), and update its associated flake.lock file
#
# This will NOT rebuild the environment, you need to do an `envil switch/shell' again afterwards
def "main update" [
    envname: string = "" # The environment whose flake.lock should be updated
    --statedir (-d) = "" # Where to read the envil state and look for flake.nix/lock files
] {
    let state = get-state $statedir
    let envname = select-envname $envname $state --verb "update"
    let flakepath = write-flake $envname $state
    ^nix flake update --flake $flakepath
    print $"Updated flake.lock for env (ansi yellow)`($envname)'(ansi reset)"
}
