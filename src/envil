#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/state.nu *

def main [] {
    main show
}

def select-envnames [preselected unique state --verb="use"] {
    if ($preselected | is-empty) {
        let prompt = $"Select the env \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb):"
        let prompt_multi = $"Select the envs \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb) \(Use <spacebar> to \(de)select one, <a> to \(de)select all)"
        
        $state.envs |
            transpose name desc |
            flatten |
            select name description? |
            update description {|e|
                $"($e.name) (ansi grey)\(($e.description))(ansi reset)"
            } |
            sort-by -i name |
            if $unique {
                input list -d description -f $prompt | [$in]
            } else {
                input list -d description -m $prompt_multi
            } |
            get name
    } else {
        $preselected
    }
}

# Print out the flake that will generate an env
def "main flake" [
    envname: string = ""
    --statedir (-d): path = "" # Where to read the envil state from
                               #
                               # If empty, will use the statedir of the current stack
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = if ($envname == "") {
        select-envnames [] true $state --verb "create a flake for"
    } else {
        $envname
    }
    generate-flake $envname $state $systems
}

def write-flakes [env_stack state] {
    let flakes = $env_stack | each {|envname|
        let flakepath = [$state.statedir env-flakes $envname] | path join
        let flake = generate-flake $envname $state
        mkdir $flakepath
        $flake | save -rf ([$flakepath flake.nix] | path join)
        if (not ([$flakepath flake.lock] | path join | path exists)) {
            do_update $flakepath
        }
        {envname: $envname, flakepath: $flakepath}
    }
    if ($flakes | length) == 1 {
        $flakes.0.flakepath
    } else {
        # Generate a temporary flake.nix that will create an env that merges those of the stack:
        let m_flakepath = [$state.statedir .tmp-flake] | path join
        let m_state = {
            inputs: ($flakes | each {{$in.envname: $"path:($in.flakepath)"}} | into record)
            envs: {
                multienv: {
                    contents: ($env_stack | each {{$in: [__current]}} | into record)
                }
            }
            statedir: $state.statedir
        }
        let flake = generate-flake "multienv" $m_state
        rm -rf $m_flakepath
        mkdir $m_flakepath
        $flake | save -rf ([$m_flakepath flake.nix] | path join)
        $m_flakepath
    }
}

# Temporarily activate some envs by starting a subshell
def "main shell" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix
                               #
                               # If empty, will use the statedir of the current stack
    --isolated (-i) # Whether to limit the PATH of the shell so it can only see the tools from the selected envs and standard UNIX paths
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    if ($env.SHELL_ENV? != null) {
        error make {msg: "Nested subshells are not supported"}
    }
    let state = get-state $statedir
    let envnames = select-envnames $envnames $unique $state --verb "use in the subshell"
    let flakepath = write-flakes $envnames $state
    let isolated_bit = if $isolated {"an isolated"} else {"a"}
    print $"(ansi grey)Starting ($isolated_bit) subshell with env\(s) (ansi yellow)($envnames)(ansi grey)...(ansi reset)"
    let merged_name = $envnames | str join "+"
    let new_path = if $isolated {
        [/usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, /bin]
    } else {
        $env.PATH
    }
    try {
        let nix_exe = (which nix).path.0
        PATH=$new_path SHELL_ENV=$merged_name run-external $nix_exe shell $"path:($flakepath)#__current"
    } catch {
        print $"(ansi grey)Last subshell command exited with (ansi yellow)($env.LAST_EXIT_CODE)(ansi reset)"
    }
}

def do_switch [envstack state] {
    let flakepath = write-flakes $envstack $state
    ^nix build $"path:($flakepath)#__current" -o ([~ .envil current] | path join | path expand -n)
    set-currents --envstack $envstack
}

# Switch the entire stack at once, potentially changing the current statedir
def "main switch" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix.
                               # 
                               # Will be recorded as the target for subsequent usages of `envil add'/`envil pop'.
                               # If empty, will keep using the same statedir as the current stack
    --reload (-r) # Reload the current stack
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    let state = get-state $statedir
    let new_stack = if $reload {
        (get-currents).envstack
    } else {
        select-envnames $envnames $unique $state --verb "switch to"
    }
    do_switch $new_stack $state
    set-currents --statedir $state.statedir
    print $"(ansi grey)Switched to statedir (ansi yellow)`($state.statedir)'(ansi grey), using env\(s) (ansi yellow)($new_stack)(ansi reset)"
}

# Add new envs on top of the stack
def "main add" [
    --unique (-u) # Whether to select just one env (in which case the env picker will come with a searchbar)
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    let state = get-state ""
    let envnames = select-envnames $envnames $unique $state --verb "add"
    do_switch ((get-currents).envstack ++ $envnames) $state
    print $"(ansi grey)Added env\(s) (ansi yellow)($envnames)(ansi grey) to the stack(ansi reset)"
}

# Remove the top env(s) from the stack
def "main pop" [
    num: int = 1 # How many envs to remove
    --all (-a) # Pop the entire stack (ignoring (num) parameter)
] {
    let state = get-state ""
    let stack = (get-currents).envstack
    let num = if $all {$stack | length} else {$num}
    let lasts = $stack | last $num
    if $lasts == [] {
        print $"(ansi grey)Nothing to pop(ansi reset)"
    } else {
        do_switch ($stack | drop $num) $state
        print $"(ansi grey)Removed (ansi yellow)($lasts)(ansi grey) from the stack(ansi reset)"
    }
}

# Remove some envs from the stack (by name)
def "main rm" [
    --unique (-u) # Whether to select just one env (in which case the env picker will come with a searchbar)
    ...envnames # Envs to remove (will open a picker if none is given)
] {
    let state = get-state ""
    let envnames = select-envnames $envnames $unique $state --verb "remove"
    let new_stack = (get-currents).envstack | where {not ($in in $envnames)}
    do_switch $new_stack $state
    print $"(ansi grey)Removed (ansi yellow)($envnames)(ansi grey) from the stack(ansi reset)"
}

def ls_or_empty [folder] {
    try {
        ls -s $folder | get name
    } catch {
        []
    }
}

# Report if some bins are present several times in your PATH
def "main checkpath" [
    --all (-a) # Check for all bins, not just those in the nix store
] {
    let bins = $env.PATH | each {|p| try {ls $p} catch {[]} | insert source $p} | flatten | rename -c {name: path} |
               insert stem {$in.path | path parse | get stem} | update path {path expand} |
               if $all { $in } else { where path starts-with /nix/store }
    let bins = $bins | group-by stem --to-table | each {{group: $in.group, items: ($in.items | uniq-by path | uniq-by source)}}
    for bin in $bins {
        if (($bin.items | length) >= 2) {
            print $"(ansi yellow)`($bin.group)'(ansi reset) is present more than once in your PATH. Found in: ($bin.items.source)"
        }
    }
}

# Print out the current state of the stack & bins in the PATH, and the same for the current subshell (if any)
def "main show" [] {
    let currents = get-currents
    if ($currents | is-empty) {
        print $"(ansi yellow)No currents envs and/or statedir(ansi reset)"
    }
    if ($currents.statedir? != null) {
        print $"- Statedir used by current stack: (ansi yellow)`($currents.statedir)'(ansi reset)"
    } else {
        print $"- No current statedir. Run (ansi yellow)`envil switch -d <statedir_path>'(ansi reset) to set it"
    }
    let bindir = [~ .envil current bin] | path join | path expand -n
    if ($bindir in $env.PATH) {
        print $"- Env\(s) on the stack: (ansi yellow)($currents.envstack)(ansi reset)"
        let binlist = $"(ls_or_empty $bindir | sort -i)"
        print $"  | Bins: ($binlist)"
    } else {
        print $"- Dir (ansi yellow)`($bindir)'(ansi reset) is not in the PATH"
    }
    if ($env.SHELL_ENV? != null) {
        let envnames = $env.SHELL_ENV | split row "+"
        print $"- Env\(s) in this subshell: (ansi yellow)($envnames)(ansi reset)"
        let binlist = $"($env.PATH | where {str ends-with "-envil/bin"} | ansi strip | each {ls_or_empty $in} | flatten | sort -i)"
        print $"  | Bins: ($binlist)"
    }
}

def do_update [flakepath] {
    try {
        ^nix flake update --flake $"path:($flakepath)"
    } catch {
        # We may be on an older version of nix where the --flake arg does not exist yet
        ^nix flake update $"path:($flakepath)"
    }
}

# Update an env's inputs (package sources) and its associated lockfile
#
# Re-loads the current stack to take into account potential changes.
# If that env is used in a subshell, you should exit and restart it.
def "main update" [
    --unique (-u) # Whether to select just one environment
    --statedir (-d): path = "" # Where to read the envil state and look for flake.nix/lock files
                               #
                               # If empty, will use the statedir of the current env stack
    --no-reload (-R) # Do not reload the current stack
    ...envnames # Envs to update (will open a picker if none is given)
] {
    let state = get-state $statedir
    let envnames = select-envnames $envnames $unique $state --verb "update"
    let flakepath = write-flakes $envnames $state
    do_update $flakepath
    print $"(ansi grey)Updated flake.lock for env\(s) (ansi yellow)($envnames)(ansi reset)"
    if (not $no_reload) {
        let stack = (get-currents).envstack
        do_switch $stack $state
        print $"(ansi grey)Reloaded current stack: (ansi yellow)($stack)(ansi reset)"
    }
}
