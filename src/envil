#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/state.nu *

def main [] {
    main show
}

def select-envs [preselected unique state --verb="use"] {
    if ($preselected | is-empty) {
        let statedir_bit = $"\(from (ansi yellow)`($state.statedir)'(ansi reset))"
        let prompt = $"Select the env ($statedir_bit)to ($verb):"
        let prompt_multi = $"Select the envs ($statedir_bit)to ($verb) \(Use <spacebar> to \(de)select one, <a> to \(de)select all)"
        
        $state.envs |
            transpose name desc |
            flatten |
            select name description? |
            update description {|e|
                $"($e.name) (ansi grey)\(($e.description))(ansi reset)"
            } |
            sort-by -i name |
            if $unique {
                input list -d description -f $prompt | [$in]
            } else {
                input list -d description -m $prompt_multi
            } |
            get name
    } else {
        $preselected
    } | wrap name | insert source $state.statedir
}

# Print out the flake that will generate an env
def "main flake" [
    envname: string = ""
    --statedir (-d): path = "" # Where to read the envil state from
                               #
                               # If empty, will use the statedir of the current stack
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = if ($envname == "") {
        select-envs [] true $state --verb "create a flake for" | get 0.name
    } else {
        $envname
    }
    generate-flake $envname $state $systems
}

def write-flakes [envstack tmp_flake_folder delete_tmp_lock] {
    let flakes = $envstack | each {|env_|
        let flakepath = [$env_.source flakes $env_.name] | path join
        let flake = generate-flake $env_.name (get-state $env_.source)
        mkdir $flakepath
        $flake | save -rf ([$flakepath flake.nix] | path join)
        if (not ([$flakepath flake.lock] | path join | path exists)) {
            do_update $flakepath
        }
        {envname: $env_.name, flakepath: $flakepath}
    }
    if ($flakes | length) == 1 {
        $flakes.0.flakepath
    } else {
        # Generate a temporary flake.nix that will create an env that merges those of the stack:
        let m_flakepath = [~ .envil tmp-flakes $tmp_flake_folder] | path join | path expand -n
        let m_state = {
            inputs: ($flakes | each {{$in.envname: $"path:($in.flakepath)"}} | into record)
            envs: {
                multienv: {
                    contents: ($envstack | each {{$in.name: [__selected]}} | into record)
                }
            }
        }
        let flake = generate-flake "multienv" $m_state
        if $delete_tmp_lock {
            rm -rf $m_flakepath
        }
        mkdir $m_flakepath
        $flake | save -rf ([$m_flakepath flake.nix] | path join)
        $m_flakepath
    }
}

# Temporarily activate some envs by starting a subshell
def "main shell" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --empty (-e) # Whether to start a shell that contains nothing, to hide the current stack. Implies --isolated
    --statedir (-d): path = "" # Where to read the envil state from. If empty, will use the last used statedir
    --isolated (-i) # Whether to limit the PATH of the shell so it can only see the tools from the selected envs and standard UNIX paths
    --reload (-r) # Use it if some updates to the envil-state.yaml are not taken into account when activating multiple envs in the shell
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    if ($env.SHELL_ENV? != null) {
        error make {msg: "Nested subshells are not supported"}
    }
    let isolated = $isolated or $empty
    let state = get-state $statedir
    let envstack = if $empty {[]} else {select-envs $envnames $unique $state --verb "use in the subshell"}
    let flakepath = write-flakes $envstack "shell" $reload
    let isolated_bit = if $isolated {"an isolated"} else {"a"}
    print $"(ansi grey)Starting ($isolated_bit) subshell with env\(s) (ansi yellow)($envstack | get name)(ansi grey)...(ansi reset)"
    let merged_name = $envstack | get name | str join "+"
    let new_path = if $isolated {
        [/usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, /bin]
    } else {
        $env.PATH
    }
    set-currents --statedir $state.statedir
    try {
        let nix_exe = (which nix).path.0
        PATH=$new_path SHELL_ENV=$merged_name run-external $nix_exe shell $"path:($flakepath)#__selected"
    } catch {
        print $"(ansi grey)Last subshell command exited with (ansi yellow)($env.LAST_EXIT_CODE)(ansi reset)"
    }
}

def do_switch [envstack state --delete-tmp-lock] {
    let flakepath = write-flakes $envstack "stack" $delete_tmp_lock
    ^nix build $"path:($flakepath)#__selected" -o ([~ .envil current] | path join | path expand -n)
    set-currents --envstack $envstack --statedir $state.statedir
}

# Switch to a new stack, or reload the current one from statedirs
def "main switch" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from. If empty, will use the last used statedir
    --reload (-r) # Reload the current stack, ignoring other args
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    let state = get-state $statedir
    let new_stack = if $reload {
        (get-currents).envstack
    } else {
        select-envs $envnames $unique $state --verb "switch to"
    }
    do_switch $new_stack $state --delete-tmp-lock
    print $"(ansi grey)Switched to env\(s) (ansi yellow)($new_stack | get name)(ansi reset)"
}

# Add new envs on top of the stack
def "main push" [
    --unique (-u) # Whether to select just one env (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from. If empty, will use the last used statedir
    ...envnames # Envs to activate (will open a picker if none is given)
] {
    let state = get-state $statedir
    let stack = (get-currents).envstack
    let new_stack = select-envs $envnames $unique ($state | update envs {reject -i ...($stack | get name)}) --verb "add to the stack"
    do_switch ($stack ++ $new_stack) $state
    print $"(ansi grey)Added env\(s) (ansi yellow)($new_stack | get name)(ansi grey) to the stack(ansi reset)"
}

# Remove the top env(s) from the stack
def "main pop" [
    --by-name (-n) # Select envs to remove by name instead
    --all (-a) # Pop the entire stack, ignoring other args
    ...num_or_envnames # How many envs 
] {
    let state = get-state ""
    let stack = (get-currents).envstack
    if ($stack | is-empty) {
        print $"(ansi grey)Nothing to pop(ansi reset)"
    } else {
        let edits = if $by_name and not $all {
            let invalid = $num_or_envnames | where {not ($in in ($stack | get name))}
            if (not ($invalid | is-empty)) {
                print $"(ansi red)Env\(s) (ansi yellow)($invalid)(ansi red) are not in the stack(ansi reset)"
                error make {msg: "Invalid env names"}
            }
            let removed = select-envs $num_or_envnames false ($state | update envs {select ...($stack | get name)}) --verb "remove" | get name
            { removed: $removed
              new_stack: ($stack | where {not ($in.name in $removed)}) }
        } else {
            let num = if $all {
                $stack | length
            } else if ($num_or_envnames | is-empty) {
                1
            } else {
                $num_or_envnames | get 0 | into int
            }
            { removed: ($stack | last $num | get name)
              new_stack: ($stack | drop $num) }
        }
        do_switch $edits.new_stack $state
        print $"(ansi grey)Removed (ansi yellow)($edits.removed)(ansi grey) from the stack(ansi reset)"
    }
}

# Move an env in the stack at a certain position. Use --bottom to move it to the lowermost position
def "main move" [
    envname # Which env to move
    new_position = 0 # Where to put it
    --bottom (-b) # Place it to the bottom instead
] {
    let stack = (get-currents).envstack | reverse
    mut new_position = if $bottom {($stack | length) - 1} else {$new_position}
    let env_ = try {
        $stack | zip (0..) | where {$in.0.name == $envname} | get 0
    } catch {
        error make {msg: $"Env ($envname) not present in the stack"}
    }
    let env_position = $env_.1
    let env_ = $env_.0
    let stack = if $env_position == 0 {
            $stack | range (1..)
        } else {
            $stack | range (0..($env_position - 1)) | append ($stack | range (($env_position + 1)..))
        }
    let stack = $stack | insert $new_position $env_
    set-currents --envstack ($stack | reverse)
    {
        "Env stack": ($stack | table)
    }
}

def ls_or_empty [folder] {
    try {
        ls -s $folder | get name
    } catch {
        []
    }
}

# Report if some bins are present several times in your PATH
def "main checkpath" [
    --all (-a) # Check for all bins, not just those in the nix store
] {
    let bins = $env.PATH | each {|p| try {ls $p} catch {[]} | insert source $p} | flatten | rename -c {name: path} |
               insert stem {$in.path | path parse | get stem} | update path {path expand} |
               if $all { $in } else { where path starts-with /nix/store }
    let bins = $bins | group-by stem --to-table | each {{group: $in.group, items: ($in.items | uniq-by path | uniq-by source)}}
    for bin in $bins {
        if (($bin.items | length) >= 2) {
            print $"(ansi yellow)`($bin.group)'(ansi reset) is present more than once in your PATH. Found in: ($bin.items.source)"
        }
    }
}

# Print out the current state of the stack & bins in the PATH, and the same for the current subshell (if any)
def "main show" [] {
    let currents = get-currents
    let bindir = [~ .envil current bin] | path join | path expand -n
    {
        "Current statedir": $currents.statedir?
        "Env stack": (if ($bindir in $env.PATH) {
                $currents.envstack? | or-else [] | reverse | table
            } else {
                "(not in PATH)"
            })
        "Bins in stack": (if ($bindir in $env.PATH) {
                ls_or_empty $bindir | sort -i | str join ", "
            } else {
                $"(ansi yellow)`($bindir)' is not present in the PATH(ansi reset)"
            })
        ...(if ($env.SHELL_ENV? != null) {
                {
                    "Envs in subshell": ($env.SHELL_ENV | split row "+" | table -i false)
                    "Bins in subshell": ($env.PATH | where {str ends-with "-envil/bin"} | ansi strip |
                                        each {ls_or_empty $in} | flatten | sort -i | str join ", ")
                }
            } else {
                {}
            })
    } | table 
}

def do_update [flakepath] {
    try {
        ^nix flake update --flake $"path:($flakepath)"
    } catch {
        # We may be on an older version of nix where the --flake arg does not exist yet
        ^nix flake update $"path:($flakepath)"
    }
}

# Update selected envs' inputs (package sources) and associated lockfiles
#
# IMPORTANT: This does not touch the stack. If you want to update you current stack, run `envil switch -r' afterwards
def "main update" [
    --unique (-u) # Whether to select just one environment
    --statedir (-d) = "": path # Where to read the envil state from and write the updated flake.lock files. If empty, uses last used statedir
    ...envnames # Envs to update (will open a picker if none is given)
] {
    let state = get-state $statedir
    let envnames = select-envs $envnames $unique $state --verb "update"
    let flakepath = write-flakes $envnames "stack" true
    do_update $flakepath
    print $"(ansi grey)Updated flake.lock files for env\(s) (ansi yellow)($envnames | get name)(ansi reset)"
}
