#!/usr/bin/env nu

use lib/gen-flake.nu *
use lib/state.nu *

def main [] {
    help main
}

def select-envnames [unique state --verb="use"] {
    let prompt = $"Select the env \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb):"
    let prompt_multi = $"Select the envs \(from (ansi yellow)`($state.statedir)'(ansi reset)) to ($verb).
Use <spacebar> to \(de)select one, <a> to \(de)select all"
    
    $state.envs |
        transpose name desc |
        flatten |
        select name description? |
        update description {|e|
            $"($e.name) (ansi grey)\(($e.description))(ansi reset)"
        } |
        sort-by -i name |
        if $unique {
            input list -d description -f $prompt | [$in]
        } else {
            input list -d description -m $prompt_multi
        } |
        get name
}

# Print out the flake that will generate the <envname> environment
def "main flake" [
    envname: string = ""
    --statedir (-d): path = "" # Where to read the envil state from
                               #
                               # If empty, will use the statedir of the current env stack
    --systems (-s): list<string> = []
    # Which systems should this flake build for. The flake will use `nixpkgs.lib.systems.flakeExposed' if <systems> is left empty
] {
    let state = get-state $statedir
    let envname = if ($envname == "") {
        select-envnames true $state --verb "create a flake for"
    } else {
        $envname
    }
    generate-flake $envname $state $systems
}

def write-flakes [env_stack state] {
    let flakes = $env_stack | each {|envname|
        let flakepath = [$state.statedir env-flakes $envname] | path join
        let flake = generate-flake $envname $state
        mkdir $flakepath
        $flake | save -rf ([$flakepath flake.nix] | path join)
        if (not ([$flakepath flake.lock] | path join | path exists)) {
            do_update $flakepath
        }
        {envname: $envname, flakepath: $flakepath}
    }
    if ($flakes | length) == 1 {
        $flakes.0.flakepath
    } else {
        # Generate a temporary flake.nix that will create an env that merges those of the stack:
        let m_flakepath = [$state.statedir .tmp-flake] | path join
        let m_state = {
            inputs: ($flakes | each {{$in.envname: $"path:($in.flakepath)"}} | into record)
            envs: {
                multienv: {
                    contents: ($env_stack | each {{$in: [__current]}} | into record)
                }
            }
            statedir: $state.statedir
        }
        let flake = generate-flake "multienv" $m_state
        rm -rf $m_flakepath
        mkdir $m_flakepath
        $flake | save -rf ([$m_flakepath flake.nix] | path join)
        $m_flakepath
    }
}

# Temporarily activate an env, by starting a subshell containing <envname>, or run a command in this subshell
def "main shell" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix
                               #
                               # If empty, will use the statedir of the current env stack
] {
    if ($env.SHELL_ENV? != null) {
        error make {msg: "Nested subshells are not supported"}
    }
    let state = get-state $statedir
    let envnames = select-envnames $unique $state --verb "use in the subshell"
    let flakepath = write-flakes $envnames $state
    print $"(ansi grey)Starting a subshell with env\(s) (ansi yellow)($envnames)(ansi grey)...(ansi reset)"
    let merged_name = $envnames | str join "+"
    try {
        SHELL_ENV=$merged_name ^nix shell $"path:($flakepath)#__current"
    } catch {
        print $"(ansi grey)Last subshell command exited with (ansi yellow)($env.LAST_EXIT_CODE)(ansi reset)"
    }
}

def do_switch [envstack state] {
    let flakepath = write-flakes $envstack $state
    ^nix build $"path:($flakepath)#__current" -o ([~ .envil current] | path join | path expand -n)
    set-currents --envstack $envstack
}

# Switch the entire stack at once, potentially changing the current statedir
def "main switch" [
    --unique (-u) # Whether to select just one environment (in which case the env picker will come with a searchbar)
    --statedir (-d): path = "" # Where to read the envil state from and write the temporary flake.nix.
                               # 
                               # Will be recorded as the target for subsequent usages of `envil add'/`envil pop'.
                               # If empty, will keep using the same statedir as the current env stack
] {
    let state = get-state $statedir
    let new_stack = select-envnames $unique $state --verb "switch to"
    do_switch $new_stack $state
    set-currents --statedir $state.statedir
    print $"(ansi grey)Switched to statedir (ansi yellow)`($state.statedir)'(ansi grey), using env\(s) (ansi yellow)($new_stack)(ansi reset)"
}

# Add a new environment on top of the stack, so its bins are put in the PATH too
def "main add" [
    envname: string = "" # Which env to add on top of the stack
] {
    let state = get-state ""
    let envname = if ($envname == "") {
        select-envnames true $state --verb "stack" | get 0
    } else {
        $envname
    }
    do_switch ((get-currents).envstack ++ [$envname]) $state
    print $"(ansi grey)Added env (ansi yellow)`($envname)'(ansi grey) on top of the stack(ansi reset)"
}

# Remove the top environment(s) of the stack
def "main pop" [
    num: int = 1 # How many envs to remove
    --all (-a) # Pop the entire stack (ignoring (num) parameter)
] {
    let state = get-state ""
    let stack = (get-currents).envstack
    let num = if $all {$stack | length} else {$num}
    let lasts = $stack | last $num
    if $lasts == [] {
        print $"(ansi grey)Nothing to pop(ansi reset)"
    } else {
        do_switch ($stack | drop $num) $state
        print $"(ansi grey)Popped (ansi yellow)($lasts)(ansi grey) from the stack(ansi reset)"
    }
}

def ls_or_empty [folder] {
    try {
        ls -s $folder | get name
    } catch {
        []
    }
}

# Report if some bins are present several times in your PATH
def "main checkpath" [
    --all (-a) # Check for all bins, not just those in the nix store
] {
    let bins = $env.PATH | each {|p| try {ls $p} catch {[]} | insert source $p} | flatten | rename -c {name: path} |
               insert stem {$in.path | path parse | get stem} | update path {path expand} |
               if $all { $in } else { where path starts-with /nix/store }
    let bins = $bins | group-by stem --to-table | each {{group: $in.group, items: ($in.items | uniq-by path | uniq-by source)}}
    for bin in $bins {
        if (($bin.items | length) >= 2) {
            print $"(ansi yellow)`($bin.group)'(ansi reset) is present more than once in your PATH. Found in: ($bin.items.source)"
        }
    }
}

# Get the current env stack and the bins it puts in the PATH, and the env activated in a subshell (if any)
def "main status" [] {
    let currents = get-currents
    if ($currents | is-empty) {
        print $"(ansi yellow)No currents envs and/or statedir(ansi reset)"
    }
    if ($currents.statedir? != null) {
        print $"- Statedir used by current stack: (ansi yellow)`($currents.statedir)'(ansi reset)"
    } else {
        print $"- No current statedir. Run (ansi yellow)`envil switch -d <statedir_path>'(ansi reset) to set it"
    }
    print $"- Env\(s) on the stack: (ansi yellow)($currents.envstack)(ansi reset)"
    let binlist = $"(ls_or_empty ([~ .envil current bin] | path join | path expand -n) | sort -i)"
    print $"  | Bins: ($binlist)"
    if ($env.SHELL_ENV? != null) {
        print $"- Env in this subshell: (ansi yellow)`($env.SHELL_ENV)'(ansi reset)"
        let binlist = $"($env.PATH | where {str ends-with "-envil/bin"} | ansi strip | each {ls_or_empty $in} | flatten | sort -i)"
        print $"  | Bins: ($binlist)"
    }
}

def do_update [flakepath] {
    try {
        ^nix flake update --flake $"path:($flakepath)"
    } catch {
        # We may be on an older version of nix where the --flake arg does not exist yet
        ^nix flake update $"path:($flakepath)"
    }
}

# Update an environment's inputs (package sources) and update its associated flake.lock file
#
# Re-loads the current stack to take into account potential changes.
# If that env is used in a subshell, you should exit and restart it.
def "main update" [
    --unique (-u) # Whether to select just one environment
    --statedir (-d): path = "" # Where to read the envil state and look for flake.nix/lock files
                               #
                               # If empty, will use the statedir of the current env stack
    --no-reload (-R) # Do not reload the current env stack
] {
    let state = get-state $statedir
    let envnames = select-envnames $unique $state --verb "update"
    let flakepath = write-flakes $envnames $state
    do_update $flakepath
    print $"(ansi grey)Updated flake.lock for env\(s) (ansi yellow)($envnames)(ansi reset)"
    if (not $no_reload) {
        let stack = (get-currents).envstack
        do_switch $stack $state
        print $"(ansi grey)Reloaded current stack: (ansi yellow)($stack)(ansi reset)"
    }
}
