use nix-printer.nu *
use statedir.nu nixpkgs_input

def or-else [defval] {
    if $in == null {$defval} else {$in}
}

def gen-one-env [env_name env_desc]: nothing -> record<inputs: list<string>, output: string, extends: list<string>> {
    mut env_inputs = []
    mut env_paths = []
    for i in ($env_desc.contents? | transpose name pkgs) {
        $env_inputs = $env_inputs | append $i.name
        for p in $i.pkgs {
            mut pkg = $"imp.($i.name).($p)"
            if ($pkg | str contains " ") {
                $pkg = $"\(($pkg))"
            }
            $env_paths = $env_paths | append $pkg
        }
    }
    for i in $env_desc.extends? {
        $env_paths = $env_paths | append $"envs.($i)"
    }
    let output = (r
        buildEnv (a
            name (s $"($env_name)-env")
            paths (l ...$env_paths)
        )
    )
    {
        inputs: $env_inputs
        output: $output
        extends: ($env_desc.extends? | or-else [])
    }
}

# Prints the flake part for $env_name from the data obtained from envil state
def output-flake [env_name systems inputs outputs] {
    (r
     (c "This has been generated by `envil'\nDO NOT EDIT MANUALLY")
     (a
        description (s $"envil environment `($env_name)'")
        inputs (rec2a $inputs)
        outputs (f inputs
            (let_
                [forEachSystem (r inputs.nixpkgs.lib.genAttrs $systems)]
                (a packages (r forEachSystem (f system
                    (let_
                        [imp (r (c "An attrset containing each input's packages for the current system")
                                builtins.mapAttrs
                                (f _ input
                                    "input.packages.${system} or input.legacyPackages.${system}")
                                inputs)
                         buildEnv (r (c "A function to make an environment")
                                     "imp.nixpkgs.buildEnv")
                         envs (r (c $"Each environment used by env `($env_name)'")
                                 (rec2a ({default: $"envs.($env_name)"} | merge $outputs)))]
                        envs))))))))
}

# Prints out the flake that will generate the <env-name> environment
export def generate-flake [
    env_name
    state
    systems: list<string> = []
] {
    # We do a BFS through the existing envs to resolve the `extends',
    # and recursively generate a buildEnv target for each extended env:
    mut to_do = [$env_name]
    mut already_done = {}
    mut generated_envs = {}
    while (not ($to_do | is-empty)) {
        let cur_name = $to_do | first
        $to_do = $to_do | skip 1
        let cur_env = try {
            $state.envs | get $cur_name
        } catch {
            error make {msg: $"Env `($cur_name)' does not exist in statedir `($state.statedir)'"}
        }
        mut cur_done = gen-one-env $cur_name $cur_env
        let extends = $cur_done.extends
        $cur_done = $cur_done | reject extends
        $generated_envs = $generated_envs | insert $cur_name $cur_done
        for i in $extends {
            if (not ($i in $already_done) and not ($i in $to_do)) {
                $to_do = $to_do | append $i
            }
        }
        $already_done = $already_done | upsert $cur_name true
    }
    
    let systems = if ($systems | is-empty) {
        "inputs.nixpkgs.lib.systems.flakeExposed"
    } else {
        (l ...($systems | each {s $in}))
    }

    # Make a table with 3 columns: 'name', 'inputs' & 'output':
    let $envs_table = $generated_envs | transpose name _contents | flatten

    mut inputs = {}
    for i in ($envs_table | each {$in.inputs} | flatten | uniq) {
        mut input_url = $state.inputs | get $i
        if (($input_url | describe) | str starts-with "record") {
            # $input_url is a record `{"<url>": [followed_input0, followed_input1, ...]}'
            let actual_url = $input_url | columns | get 0
            for follow_link in ($input_url | values | transpose src dest) {
                $inputs = $inputs | insert $"($i).inputs.($follow_link.src).follows" (s $follow_link.dest)
            }
            $input_url = $actual_url
        }
        # else $input_url is already just an URL string
        $inputs = $inputs | insert $"($i).url" $input_url
    }
    if (not ("nixpkgs.url" in $inputs)) {
        $inputs = $inputs | insert "nixpkgs.url" $nixpkgs_input.nixpkgs
    }

    let $outputs = $envs_table | each {[$in.name $in.output]} | into record

    output-flake $env_name $systems $inputs $outputs |
    if ($env.ENVIL_NIX_FORMATTER? == null) {
        $in
    } else {
        $in | run-external $env.ENVIL_NIX_FORMATTER
    }
}
